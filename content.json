{"meta":{"title":"铭心客的博客","subtitle":null,"description":null,"author":"铭心客","url":"http://yoursite.com"},"pages":[{"title":"About me","date":"2018-05-27T14:36:59.000Z","updated":"2018-05-28T15:40:53.586Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"QT C++爱生活，爱Coding Hey，大家好我是铭心客，英文名Martin Ding。我是一个”菜鸟”C++软件工程师,虽然是一个C++软件工程师，但是工作中一直用QT开发，对于QT库比C++标准库还熟。但是这不是我想要的，我要成为一个真正C++软件工程师，所以我一直在学习C++以及C++11。 我的兴趣比较广泛，除了C++还喜欢学习其它各种开发语言，如C# 、Python、Java 等；都只学过虽然最终只是学会了皮毛，但是后面会继续学习。 工作有几年但是对于设计模式却不是很熟悉，在软件架构设计上总是很糟糕，后面会重点学习软件设计模式。有兴趣的朋友可以一起研究，更欢迎大神们提点提点。 工作这几年都是用QT，加过不少群，看过不少博客；其中从一去、二三里（博客地址）的博客中受益良多,还有QQ群Qt分享&amp;&amp;交流①（26197884）、QML分享&amp;&amp;交流（26188347），有兴趣的朋友可以加入我们。在此感谢一去、二三里博主，在这工作的几年里很多问题都是看你的博客解决的，谢谢！！！ 联系方式：QQ: 745688760 邮箱：mingxinke@hotmail.com"},{"title":"categories","date":"2018-05-27T14:43:35.761Z","updated":"2018-05-27T14:43:35.761Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-27T14:13:30.828Z","updated":"2018-05-27T14:13:30.828Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"QT实现系统托盘","slug":"systemTrayIcon","date":"2018-05-29T15:37:37.000Z","updated":"2018-06-01T14:36:13.795Z","comments":true,"path":"2018/05/29/systemTrayIcon/","link":"","permalink":"http://yoursite.com/2018/05/29/systemTrayIcon/","excerpt":"QT中添加系统托盘使用 QSystemTrayIcon 类","text":"QT中添加系统托盘使用 QSystemTrayIcon 类 方法 void setContextMenu(QMenu *menu) 设置托盘的右键菜单 void setIcon(const QIcon &amp;icon) 设置托盘的图标 void setToolTip(const QString &amp;tip) 设置鼠标放上去的提示信息 void showMessage(const QString &amp;title,const QString &amp;message, QSystemTrayIcon::MessageIcon icon = QSystemTrayIcon::Information, int millisecondsTimeoutHint = 10000) 这个函数可以显示图示信息，参数分别为标题、信息内容、信息类型、显示时间信息类型如下： 图标类型 | 值 | 说明—————————- | —- | ——————–QSystemTrayIcon::NoIcon | 0 | 没有图标显示.QSystemTrayIcon::Information | 1 | 信息图标显示.QSystemTrayIcon::Warning | 2 | 警告图标显示.QSystemTrayIcon::Critical | 3 | 出错图标显示. 信号 void activated(QSystemTrayIcon::ActivationReason reason) 用户激活图标时发出，参数为激活方式，详情如下： 激活方式 值 说明 SystemTrayIcon::Unknown 0 未知原因 QSystemTrayIcon::Context 1 请求系统托盘条目的上下文菜单。 QSystemTrayIcon::DoubleClick 2 双击系统托盘 QSystemTrayIcon::Trigger 3 点击系统托盘 QSystemTrayIcon::MiddleClick 4 鼠标中键点击系统托盘 void messageClicked() 当用户点击消息提示时发出 代码头文件代码：12345678910111213141516171819202122232425262728293031323334#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QSystemTrayIcon&gt;QT_BEGIN_HEADERclass QAction;QT_END_HEADERclass MainWindow : public QMainWindow&#123; Q_OBJECTpublic: explicit MainWindow(QWidget *parent = 0); ~MainWindow();protected slots: void widgetScreenshot(); // 界面截图 // 托盘图标点击处理槽函数 void trayIconActivated(QSystemTrayIcon::ActivationReason reason);private: void initWidget(); // 初始化界面private: QSystemTrayIcon* m_pTrayIcon; QAction* m_pActOpen; QAction* m_pActClose; QAction* m_pActScreen;&#125;;#endif // MAINWINDOW_H cpp文件代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include \"mainwindow.h\"#include &lt;QStandardPaths&gt;#include &lt;QGuiApplication&gt;#include &lt;QScreen&gt;#include &lt;QAction&gt;#include &lt;QMenu&gt;#include &lt;QDateTime&gt;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; initWidget();&#125;MainWindow::~MainWindow()&#123;&#125;// 初始化界面void MainWindow::initWidget()&#123; m_pTrayIcon = new QSystemTrayIcon(this); m_pTrayIcon-&gt;setIcon(QIcon(\":/Icon/Resources/qt-logo.ico\")); //设置图标 m_pTrayIcon-&gt;setToolTip(tr(\"System Tray Icon\")); //设置鼠标放上去显示的信息 //右键菜单 QMenu *pMenu = new QMenu(this); // 打开界面 m_pActOpen = new QAction(tr(\"Open widget\"), this); connect(m_pActOpen, SIGNAL(triggered()), this, SLOT(show())); pMenu-&gt;addAction(m_pActOpen); // 关闭界面 m_pActClose = new QAction(tr(\"Close widget\"), this); connect(m_pActClose, SIGNAL(triggered()), this, SLOT(hide())); pMenu-&gt;addAction(m_pActClose); // 界面截图 m_pActScreen = new QAction(tr(\"Widget screenshot\"), this); connect(m_pActScreen, SIGNAL(triggered()), this, SLOT(widgetScreenshot())); pMenu-&gt;addAction(m_pActScreen); m_pTrayIcon-&gt;setContextMenu(pMenu); //设置右键菜单 connect(m_pTrayIcon, SIGNAL(activated(QSystemTrayIcon::ActivationReason)), this, SLOT(trayIconActivated(QSystemTrayIcon::ActivationReason))); m_pTrayIcon-&gt;show(); //显示&#125;// 界面截图void MainWindow::widgetScreenshot()&#123; // 获取屏幕类 QScreen *pScreen = QGuiApplication::primaryScreen(); // 获取第一个屏幕的图片 QPixmap mPixmap = pScreen-&gt;grabWindow(0); // 获取系统图片目录 QString savePath = QStandardPaths::writableLocation(QStandardPaths::PicturesLocation); // 设置名称为当前时间 savePath = QString( \"%1/%2.png\").arg(savePath).arg(QDateTime::currentDateTime().toString(\"yyyyMMddHHmmss\")); // 保存图片 qDebug() &lt;&lt; \"savePath\" &lt;&lt; savePath; mPixmap.save(savePath);&#125;void MainWindow::trayIconActivated(QSystemTrayIcon::ActivationReason reason)&#123; switch(reason) &#123; case QSystemTrayIcon::Trigger: // 鼠标点击 setWindowState(Qt::WindowActive); activateWindow(); break; default: break; &#125;&#125; 显示效果","categories":[{"name":"QT","slug":"QT","permalink":"http://yoursite.com/categories/QT/"}],"tags":[{"name":"QT","slug":"QT","permalink":"http://yoursite.com/tags/QT/"},{"name":"系统托盘","slug":"系统托盘","permalink":"http://yoursite.com/tags/系统托盘/"}]},{"title":"QT实现屏幕截图","slug":"screenshort","date":"2018-05-29T15:37:14.000Z","updated":"2018-06-01T14:39:59.233Z","comments":true,"path":"2018/05/29/screenshort/","link":"","permalink":"http://yoursite.com/2018/05/29/screenshort/","excerpt":"屏幕截图是非常常用的功能，但是一直没有自己写过，现在使用QT实现非常简单的全屏截图。屏幕截图主要使用了QGuiApplication类、QScreen类。QGuiApplication类管理GUI应用程序的控制流和主设置。","text":"屏幕截图是非常常用的功能，但是一直没有自己写过，现在使用QT实现非常简单的全屏截图。屏幕截图主要使用了QGuiApplication类、QScreen类。QGuiApplication类管理GUI应用程序的控制流和主设置。 功能实现代码很简单，只有一个函数，具体代码如下： 123456789101112131415// 界面截图void MainWindow::widgetScreenshot()&#123; // 获取屏幕类 QScreen *pScreen = QGuiApplication::primaryScreen(); // 获取第一个屏幕的图片 QPixmap mPixmap = pScreen-&gt;grabWindow(0); // 获取系统图片目录 QString savePath = QStandardPaths::writableLocation(QStandardPaths::PicturesLocation); // 设置名称为当前时间 savePath = QString( \"%1/%2.png\").arg(savePath).arg(QDateTime::currentDateTime().toString(\"yyyyMMddHHmmss\")); // 保存图片 qDebug() &lt;&lt; \"savePath\" &lt;&lt; savePath; mPixmap.save(savePath);&#125; 截图放在了系统图片目录： 下面详细介绍 QGuiApplication 类和 QScreen类。 QGuiApplication类 QGuiApplication类管理GUI应用程序的控制流和主设置。QGuiApplication包含主事件循环，其中所有来自窗口系统和其他源的事件都被处理和发送。它还处理应用程序的初始化和终结，并提供会话管理。此外，QGuiApplication处理大多数系统范围和应用程序范围的设置。对于使用Qt的任何GUI应用程序，无论应用程序在任何给定时间是否有0、1、2或更多窗口，都有一个QGuiApplication对象。对于非GUI Qt应用程序，使用QCoreApplication，因为它不依赖于Qt GUI模块。对于基于Qt的Qt应用程序，使用QApplication代替，因为它提供了创建QWidget实例所需的一些功能。通过实例()函数访问QGuiApplication对象，该函数返回相当于全局qApp指针的指针。QGuiApplication的主要职责范围是: 它使用用户的桌面设置来初始化应用程序，例如palette()、font()和styleHints()。它跟踪这些属性，以防止用户在全局环境中更改桌面，例如通过某种控制面板。 它执行事件处理，这意味着它从底层窗口系统接收事件并将它们分派给相关的小部件。您可以使用sendEvent()和postEvent()将您自己的事件发送到windows。它解析常见的命令行参数，并相应地设置其内部状态。 它提供了通过 translate()对用户可见的字符串的本地化。 它提供了一些像 clipboard()这样的神奇的对象。 它知道应用程序的窗口。您可以使用topLevelAt()来询问哪个窗口位于某个位置，然后获取一个topLevelWindows()列表，等等。 它管理应用程序的鼠标光标处理，见setOverrideCursor() 它为复杂的会话管理提供支持。这使得应用程序可以在用户注销时优雅地终止，如果不可能终止关闭过程，甚至在将来的会话中保存整个应用程序的状态。查看issession恢复()、sessionId()和commitDataRequest()和saveStateRequest()以获取详细信息。由于QGuiApplication对象执行了这么多的初始化，所以必须在创建与用户界面相关的其他对象之前创建它。QGuiApplication还处理常见的命令行参数。因此，在对argv的任何解释或修改之前创建它通常是一个好主意。 公有函数 qreal QGuiApplication::devicePixelRatio() const 返回系统中发现的最高屏幕设备像素比率。这是物理像素和设备独立像素之间的比率。只有你不知道你的目标窗口时，才使用此函数。如果知道目标窗口，则使用QWindow::devicePixelRatio()。 bool QGuiApplication::isSavingSession() const 如果应用程序当前保存会话，则返回true；否则返回false。当commitDataRequest()和saveStateRequest()被释放时，这是正确的，但是当窗口随后被会话管理关闭时也是如此。 bool QGuiApplication::isSessionRestored() const 如果应用程序已从较早的会话恢复，则返回true;否则返回false。 QString QGuiApplication::sessionId() const 返回当前会话的标识。如果这个应用程序从较早的会话恢复，此标识与前一会话中的标识符相同。对于不同应用程序和同一应用程序的不同实例，会话标识符都是唯一的。 QString QGuiApplication::sessionKey() const 在当前会话中返回密钥。如果应用程序从较早的会话中恢复，此键与前一会话结束时相同。每次保存会话时，会话密钥都会发生改变。如果关闭过程被取消，则在再次关闭会话时将使用另一会话密钥。 静态公有函数 QWindowList QGuiApplication::allWindows() 返回应用程序中所有的窗口列表，如果程序没有窗口，列表为空。 applicationDisplayName : QString QString applicationDisplayName()void setApplicationDisplayName(const QString &amp;name) 此属性保存该应用程序的用户可见名称。如果没有设置，应用程序显示名称默认为应用程序名称。 Qt::ApplicationState QGuiApplication::applicationState() 返回应用程序的当前状态。您可以对应用程序状态更改做出响应，以执行诸如停止/恢复cpu密集型任务、释放/加载资源或保存/恢复应用程序数据等操作。状态如下：应用状态 | 值 | 说明———————— | ———- | ——-Qt::ApplicationSuspended | 0x00000000 | 应用程序即将暂停。当进入这个状态时，应用程序应该保存它的状态，停止所有的活动，并准备好让代码执行停止。暂停时，应用程序可以在没有进一步警告的情况下随时被杀死(例如，当低内存迫使操作系统清除暂停的应用程序时)。Qt::ApplicationHidden | 0x00000001 | 应用程序隐藏并在后台运行。这是需要进行后台处理的应用程序的正常状态，比如播放音乐，而用户与其他应用程序交互。在进入这个状态时，应用程序应该释放所有图形资源。Qt::ApplicationInactive | 0x00000002 | 应用程序是可见的，但没有选择在前面。在桌面平台上，这通常意味着用户激活了另一个应用程序。在移动平台上，当操作系统用输入的呼叫或短信来打断用户时，进入这个状态更为常见。在这种状态下，考虑减少cpu密集型任务。Qt::ApplicationActive | 0x00000003 | 应用程序是可见的，并且被显示在前面。 void QGuiApplication::changeOverrideCursor(const QCursor &amp;cursor) 更改当前活动的应用程序覆盖当前的光标。注意：如果没有调用setOverrideCursor()，则该函数没有效果。 QClipboard *QGuiApplication::clipboard() 返回剪切板的交互对象 desktopFileName : QString QString desktopFileName()void setDesktopFileName(const QString &amp;name) 此属性保存此应用程序的桌面条目的基本名称。这是一个文件名称，没有完整的路径，它是根据freedesktop desktop entry规范来表示这个应用程序的桌面条目。 bool QGuiApplication::desktopSettingsAware() 如果Qt设置为使用系统的标准颜色、字体等，则返回true;否则返回false。默认是正确的。 int QGuiApplication::exec() 进入主事件循环并等待直到exit()被调用，然后返回被设置为exit()的值(如果exit()调用exit()，则为0)。需要调用此函数来启动事件处理。主事件循环从窗口系统接收事件，并将这些事件分派给应用程序小部件。通常，在调用exec()之前不会发生用户交互。为了使您的应用程序执行空闲处理，例如，在没有挂起事件的情况下执行一个特殊的函数，使用一个带有0超时的QTimer。可以使用processEvents()实现更高级的空闲处理方案。我们建议您将清理代码连接到aboutToQuit()信号，而不是将其放入应用程序的main()函数中。这是因为，在某些平台上，QApplication::exec()调用可能不会返回。 QObject *QGuiApplication::focusObject() 返回当前活动窗口中的QObject，该窗口将是与焦点相关的事件的最终接收方，例如关键事件。 QWindow *QGuiApplication::focusWindow() 返回接收与焦点相关的事件的QWindow，例如关键事件。 QFont QGuiApplication::font() 返回应用程序默认的字体 QInputMethod *QGuiApplication::inputMethod() 返回输入的方法。输入方法返回有关虚拟键盘的状态和位置的属性。它还提供关于当前焦点输入元素位置的信息。 bool QGuiApplication::isFallbackSessionManagementEnabled() 返回QGuiApplication是否将使用回退会话管理。默认是正确的。如果这是真的，会话管理器允许用户交互，QGuiApplication将尝试在提交任务()后关闭顶层窗口。如果窗口不能关闭，会话关闭将被取消，应用程序将继续运行。 Qt::KeyboardModifiers QGuiApplication::keyboardModifiers() 返回键盘上修饰符键的当前状态。当事件队列清空后，将自动更改键盘状态(QEvent::KeyPress和QEvent::KeyRelease事件)，当前状态被同步更新。应该注意的是，这可能并没有反映在调用时在输入设备上所持有的实际的键，而是在上述事件中最后一次报告的修饰符。如果没有密钥，Qt::NoModifier返回。 QWindow *QGuiApplication::modalWindow() 返回最近显示的模式窗口。如果没有显示模式窗口，则该函数返回零。模式窗口是一个窗口，它的modality属性设置为Qt::WindowModal或Qt::ApplicationModal。在用户可以继续使用程序的其他部分之前，必须关闭一个模式窗口。模式窗口是在堆栈中组织的。这个函数将返回堆栈顶部的模式窗口。 Qt::MouseButtons QGuiApplication::mouseButtons() 返回鼠标上的按钮的当前状态。当前状态是同步更新的，因为事件队列清空了会自动改变鼠标状态的事件(QEvent: MouseButtonPress和QEvent::MouseButtonRelease事件)。 QCursor *QGuiApplication::overrideCursor() 返回活动的应用程序覆盖光标。如果没有定义应用程序光标，则该函数返回0。 QPalette QGuiApplication::palette() 返回默认的应用程序调色板。 QFunctionPointer QGuiApplication::platformFunction(const QByteArray &amp;function) 从平台插件匹配函数返回一个函数指针。 platformName : const QString QString platformName() 此属性包含底层平台插件的名称。QPA平台插件位于qtbase\\src\\plugins\\platform中。支持如下平台： android cocoa（macOS） directfb eglfs（平台插件，它在EGL和OpenGL ES 2.0之上运行Qt5应用程序，而没有实际的窗口系统） ios （也可以被使用tvOS） kms（一个使用内核modesetting和DRM(直接呈现管理器)的实验性平台插件） linuxfb minimal （最小化是一个例子，可以使用该插件在没有GUI的环境中运行GUI应用程序） minimalegl（插件例子） offscreen openwwfd qnx windows xcb（普通桌面Linux平台上使用的X11插件） QPlatformNativeInterface *QGuiApplication::platformNativeInterface() 返回平台的本机接口，用于平台特定功能。 QScreen * const QScreen primaryScreen()信号：void primaryScreenChanged(QScreen screen) 此属性保存应用程序的主(或默认)屏幕。这将是最初显示QWindows的屏幕，除非另有说明。 Qt::KeyboardModifiers QGuiApplication::queryKeyboardModifiers() 查询并返回键盘上修饰符键的状态。与keyboardmodifier不同，该方法返回在调用该方法时保存在输入设备上的实际密钥。它不依赖于此进程接收到的按键事件，这使得在移动窗口时检查修饰符成为可能。注意，在大多数情况下，您应该使用keyboardModifiers()，因为它包含了修饰符的状态，因为它包含了当前处理的事件时的状态。 QList screens() 返回与应用程序连接的窗口系统相关的所有屏幕的列表。 QScreen类公有函数 int QScreen::angleBetween(Qt::ScreenOrientation a, Qt::ScreenOrientation b) const 方便函数计算旋转角度，从旋转a到旋转b。Qt::ScreenOrientation枚举类型指定屏幕可能具有的各种方向，具体如下：类型 | 值 | 说明———————— | ———- |——Qt::PrimaryOrientation | 0x00000000 | 显示的主要取向。Qt::LandscapeOrientation | 0x00000002 | 景观朝向，显示宽度大于显示高度。Qt::PortraitOrientation | 0x00000001 | 人像定位，显示高度大于显示宽度，相对于景观顺时针旋转90度。Qt::InvertedLandscapeOrientation | 0x00000008 | 倒转的景观朝向，相对于景观旋转180度。Qt::InvertedPortraitOrientation | 0x00000004 | 倒置的人像方向，旋转180度相对于人像。 availableGeometry : const QRect QRect availableGeometry() const信号：void availableGeometryChanged(const QRect &amp;geometry) 此属性以像素为单位保存屏幕可用的几何图形。可用的几何图形是不包括窗口管理器保留区域的几何图形，如任务栏和系统菜单。 availableSize : const QSize QSize availableSize() const信号：void availableGeometryChanged(const QRect &amp;geometry) 此属性以像素为单位保存屏幕的可用大小。可用的大小是不包括窗口管理器预留区域(如任务栏和系统菜单)的大小。 availableVirtualGeometry : const QRect QRect availableVirtualGeometry() const信号：void virtualGeometryChanged(const QRect &amp;rect) 此属性保存该屏幕所属的虚拟桌面的可用几何图形。返回与此屏幕对应的虚拟桌面的可用几何图形。这是虚拟兄弟姐妹的单个可用几何图形的联合。 availableVirtualSize : const QSize QSize availableVirtualSize() const信号：void virtualGeometryChanged(const QRect &amp;rect) 此属性保存该屏幕所属的虚拟桌面的可用大小。返回与此屏幕对应的虚拟桌面的可用像素大小。这是虚拟兄弟的单个可用几何图形的组合大小。 depth : const int int depth() const 此属性保存屏幕的颜色深度 devicePixelRatio : const qreal qreal devicePixelRatio() const信号：void physicalDotsPerInchChanged(qreal dpi) 此属性保存物理像素和与设备无关的像素之间的屏幕比值。返回屏幕的物理像素与设备独立像素之间的比率。普通的数值是1.0在正常显示和2.0在“视网膜”显示。更高的值也是可能的。 geometry : const QRect QRect geometry() const信号：void geometryChanged(const QRect &amp;geometry) 此属性以像素为单位保存屏幕的几何图形。 QPixmap QScreen::grabWindow(WId window, int x = 0, int y = 0, int width = -1, int height = -1) 创建并返回一个由QRect(x, y, width, height)限制的给定窗口内容所构建的像素图。参数(x, y)指定窗口中的偏移量，而(宽度、高度)指定要复制的区域。如果宽度为负，函数将所有内容复制到窗口的右边框。如果高度为负，则函数将所有内容复制到窗口的底部。可以使用QWidget: winId()函数检索窗口系统标识符。使用窗口标识符而不是QWidget的基本原理是启用不属于应用程序、窗口系统框架等的窗口。 QPlatformScreen *QScreen::handle() const 获取平台屏幕手柄 bool QScreen::isLandscape(Qt::ScreenOrientation o) const 如果o是横景或倒景，则返回真值的便利函数;否则返回false。 bool QScreen::isPortrait(Qt::ScreenOrientation o) const 如果o是竖式或倒立式，则返回true的便利函数;否则返回false。 logicalDotsPerInch : const qreal qreal logicalDotsPerInch() const信号：void logicalDotsPerInchChanged(qreal dpi) 此属性保存每英寸逻辑点或像素的数量。此值可用于将字体点大小转换为像素大小。这是一个方便的属性，就是logicalDotsPerInchX和logicalDotsPerInchY属性的平均值。 logicalDotsPerInchX : const qreal qreal logicalDotsPerInchX() const信号：void logicalDotsPerInchChanged(qreal dpi) 此属性保存水平方向上每英寸逻辑点或像素的数量。此值用于将字体点大小转换为像素大小。 logicalDotsPerInchY : const qreal qreal logicalDotsPerInchY() const信号：void logicalDotsPerInchChanged(qreal dpi) 此属性保存垂直方向上每英寸逻辑点或像素的数量。此值用于将字体点大小转换为像素大小。 QRect QScreen::mapBetween(Qt::ScreenOrientation a, Qt::ScreenOrientation b, const QRect &amp;rect) const 在两个屏幕朝向之间绘制矩形。 name : const QString QString name() cons 此属性包含表示屏幕的用户外观字符串。例如，在X11上，它们对应于XRandr屏幕名称，通常是“VGA1”、“HDMI1”等。 nativeOrientation : const Qt::ScreenOrientation Qt::ScreenOrientation nativeOrientation() const 此属性保存本机屏幕定向。屏幕的本机方向是设备的logo标签以正确的方式出现的方向，或者Qt: PrimaryOrientation(如果平台不支持这个功能的话)。本机方向是硬件的属性，不会改变。 orientation : const Qt::ScreenOrientation Qt::ScreenOrientation orientation() const信号：void orientationChanged(Qt::ScreenOrientation orientation) 此属性保存屏幕方向。屏幕方向表示显示的物理方向。例如，移动设备的屏幕方向会根据手持方式而改变。对方向的更改可能会也可能不会触发对屏幕主方向的更改。对该属性的更改将通过orientationUpdateMask()进行过滤，因此为了接收方向更新，应用程序必须首先调用setOrientationUpdateMask()，并使用希望接收的方向的掩码。 Qt::ScreenOrientations QScreen::orientationUpdateMask() const 返回当前设置的方向更新掩码。 physicalDotsPerInch : const qreal qreal physicalDotsPerInch() const信号：void physicalDotsPerInchChanged(qreal dpi) 此属性保存每英寸的物理点或像素个数。这个值表示屏幕显示的像素密度。根据底层系统提供的信息，价值可能不是完全准确的。这是一种便利性质它只是物理和物理的平均性质。 physicalDotsPerInchX : const qreal qreal physicalDotsPerInchX() const信号：void physicalDotsPerInchChanged(qreal dpi) 这个属性包含水平方向上每英寸的物理点或像素的数量。这个值表示屏幕显示的实际水平像素密度。根据底层系统提供的信息，价值可能不是完全准确的。 physicalDotsPerInchY : const qreal qreal physicalDotsPerInchY() const信号：void physicalDotsPerInchChanged(qreal dpi) 这个属性包含垂直方向上每英寸的物理点或像素的数量。这个值表示屏幕显示的实际水平像素密度。根据底层系统提供的信息，价值可能不是完全准确的。 physicalSize : const QSizeF QSizeF physicalSize() const信号：void physicalSizeChanged(const QSizeF &amp;size) 此属性保存屏幕的物理大小(以毫米为单位)。物理大小表示屏幕显示的实际物理尺寸。根据底层系统提供的信息，价值可能不是完全准确的。 primaryOrientation : const Qt::ScreenOrientation Qt::ScreenOrientation primaryOrientation() const信号：void primaryOrientationChanged(Qt::ScreenOrientation orientation) 此属性保留主屏幕方向。如果屏幕几何图形的宽度大于或等于它的高度，则主屏幕方向为Qt::LandscapeOrientation方向，否则则为 Qt::PortraitOrientation。当屏幕方向改变时(例如，当显示被旋转时)，这个属性可能会改变。但是，这种行为是与平台相关的，通常可以在应用程序清单文件中指定。 refreshRate : const qreal qreal refreshRate() const信号：void refreshRateChanged(qreal refreshRate) 此属性保存Hz中屏幕的大致垂直刷新速度。 void QScreen::setOrientationUpdateMask(Qt::ScreenOrientations mask) 设置应用程序感兴趣的接收与此屏幕相关的更新的方向。 size : const QSize QSize size() const信号：void geometryChanged(const QRect &amp;geometry) 此属性保存屏幕的像素分辨率。 QTransform QScreen::transformBetween(Qt::ScreenOrientation a, Qt::ScreenOrientation b, const QRect &amp;target) const 方便函数，用于计算从定位a定义的坐标系映射到定位b和目标维目标定义的坐标系的变换。 virtualGeometry : const QRect QRect virtualGeometry() const信号：void virtualGeometryChanged(const QRect &amp;rect) 此属性保存该屏幕所属的虚拟桌面的像素几何。返回与此屏幕对应的虚拟桌面的像素几何。这是虚拟桌面的各个几何图形的联合。 QList QScreen::virtualSiblings() const 获取屏幕的虚拟桌面。","categories":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"屏幕截图","slug":"屏幕截图","permalink":"http://yoursite.com/tags/屏幕截图/"}]},{"title":"Markdown语法","slug":"mduse","date":"2018-05-25T14:07:54.000Z","updated":"2018-05-29T11:34:14.614Z","comments":true,"path":"2018/05/25/mduse/","link":"","permalink":"http://yoursite.com/2018/05/25/mduse/","excerpt":"概述宗旨Markdown语法的 目标是实现[易读易写]Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。","text":"概述宗旨Markdown语法的 目标是实现[易读易写]Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 兼容HTMLMarkdown语法的目标是:成为一种适用于网络的书写语言。Markdown不是要取代HTML，甚至也没有要和它相近，它的语法种类很少，只对应HTML标记的一小部分Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。要制约的只有一些 HTML 区块元素――比如&lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt;等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的标签。例子如下：123456789这是一个普通段落。&lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;这是另一个普通段落。 这是一个普通段落。 Foo 这是另一个普通段落。 区块元素段落和换行一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;br /&gt; 标签。 标题Markdown支持两种标题的语法：类Setext和atx形式。类Setext形式是用底线的形式，利用=(最高阶标题)和-(第二阶标题)，任何数量的 = 和 - 都可以有效果。例如： This is an H1This is an H21234This is an H1=============This is an H2------------- 类Atx形式则是在行首插入1到6个#，对应到标题1到6阶，例如： 这是 H1这是 H2这是 H6123# 这是 H1## 这是 H2###### 这是 H6 区块引用 BlockquotesMarkdown 标记区块引用是使用类似 email 中用&gt;的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上&gt;： This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上&gt;： This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的&gt;： This is the first level of quoting. This is nested blockquote. Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表Markdown支持有序和无序列表。无需列表中使用星号、加号或者减号为列表标记： red Green Blue 123* red* Green* Blue 等同于：123+ Red+ Green+ Blue 也等同于：123- Red- Green- Blue 有序列表则使用数字接着一个英文句点： Bird McHale Parish 1231. Bird2. McHale3. Parish 很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：12345&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt; 你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 标签包起来，举例来说： 1234567* Bird* Magic转为&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;Magic&lt;/li&gt;&lt;/ul&gt; 12345678* Bird* Magic转为&lt;ul&gt;&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：1234567891. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：1234567* This is a list item with two paragraphs. This is the second paragraph in the list item. You&apos;reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.* Another item in the same list. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：123* 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法：11986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。1986. What a great season.11986\\. What a great season. 代码区块和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，要和上一行空一行 例如，下面的输入： 这是一个普通段落： 这是一个代码区块 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。也可以使用三个```表示 1234if(a&gt;b)&#123; a = 10;&#125; 区段元素链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。不管是哪一种，链接文字都是用 [方括号] 来标记。要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：This is an example inline link. This link has no title attribute.123This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. 会产生：12345&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;an example&lt;/a&gt; inline link.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has notitle attribute.&lt;/p&gt; 如果你是要链接到同样主机的资源，你可以使用相对路径： 1See my [About](/about/) page for details. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： 链接 “请点击这里”1[链接](http://example.com/) &quot;请点击这里&quot; 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同：123[foo]: http://example.com/ &quot;Optional Title Here&quot;[foo]: http://example.com/ &apos;Optional Title Here&apos;[foo]: http://example.com/ (Optional Title Here) 请注意： 有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。链接网址也可以用尖括号包起来：1[id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 强调Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong&gt;，例如： single asteriskssingle underscoresdouble asterisksdouble underscores1234*single asterisks*_single underscores_**double asterisks**__double underscores__ 会转成1234&lt;em&gt;single asterisks&lt;/em&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;strong&gt;double underscores&lt;/strong&gt; 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。强调也可以直接插在文字中间：un*frigging*believable但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：\\*this text is surrounded by literal asterisks\\* 删除线删除线 在文字两边加 双波浪号~~删除线~~ 下划线在空白行下方添加三条“-”横线。 强制换行在行尾输入两个空格这个就是另一行 代码如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：Use the printf() function.Use the `printf()` function.这段语法会产生：&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;多行代码可以使用三个 ` 图片很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。行内式的图片语法看起来像是：123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 参考式的图片语法则长得像这样：![Alt text][id]「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：[id]: url/to/image &quot;Optional title attribute&quot; 表格Tables First Header Second Header Content Cell Content Cell Content Cell Content Cell 其它自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：&lt;http://example.com/&gt;Markdown会转成：&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：&#x6d;&#x69;&#x6e;&#103;&#x78;&#105;&#110;&#x6b;&#101;&#x40;&#104;&#x6f;&#x74;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&lt;mingxinke@hotmail.com&gt;Markdown会转成：&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt; 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），你可以在星号的前面加上反斜杠：\\*literal asterisks\\*Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：123456789101112\\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 转自http://wowubuntu.com/markdown/","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]},{"title":"设置QPushButton的图标在文本的后面","slug":"my-first-blog","date":"2018-05-23T14:40:54.000Z","updated":"2018-05-29T11:34:01.852Z","comments":true,"path":"2018/05/23/my-first-blog/","link":"","permalink":"http://yoursite.com/2018/05/23/my-first-blog/","excerpt":"设置按钮的布局方向从右到左，这时图标的位置就在文本的后面了。代码如下：","text":"设置按钮的布局方向从右到左，这时图标的位置就在文本的后面了。代码如下：12// 设置布局的方向从右到左m_pBtnUser-&gt;setLayoutDirection(Qt::RightToLeft); 效果如下： 但是由于我们使用了菜单所以菜单图标位置也错了，下面使用css样式表设置菜单图标位置：12345QPushButton#btnUser::menu-indicator &#123; subcontrol-position: left center; subcontrol-origin: padding; left: 2px;&#125; 最终效果：","categories":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"QPushButton","slug":"QPushButton","permalink":"http://yoursite.com/tags/QPushButton/"},{"name":"图标","slug":"图标","permalink":"http://yoursite.com/tags/图标/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-23T14:14:12.105Z","updated":"2018-05-29T09:15:09.202Z","comments":true,"path":"2018/05/23/hello-world/","link":"","permalink":"http://yoursite.com/2018/05/23/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartMarkdown Preview EnhancedCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}